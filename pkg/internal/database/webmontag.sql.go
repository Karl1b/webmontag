// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: webmontag.sql

package database

import (
	"context"
	"database/sql"
)

const associateLinkWithPage = `-- name: AssociateLinkWithPage :exec
INSERT INTO pageslinks (pages_id, links_id) VALUES ($1, $2)
`

type AssociateLinkWithPageParams struct {
	PagesID sql.NullInt32 `json:"pages_id"`
	LinksID sql.NullInt32 `json:"links_id"`
}

func (q *Queries) AssociateLinkWithPage(ctx context.Context, arg AssociateLinkWithPageParams) error {
	_, err := q.db.ExecContext(ctx, associateLinkWithPage, arg.PagesID, arg.LinksID)
	return err
}

const createPage = `-- name: CreatePage :one
INSERT INTO pages (domain,searchDeep,maxSearchDeep) VALUES ($1, $2 , $3) RETURNING id, domain, searchdeep, maxsearchdeep
`

type CreatePageParams struct {
	Domain        sql.NullString `json:"domain"`
	Searchdeep    sql.NullInt32  `json:"searchdeep"`
	Maxsearchdeep sql.NullInt32  `json:"maxsearchdeep"`
}

func (q *Queries) CreatePage(ctx context.Context, arg CreatePageParams) (Page, error) {
	row := q.db.QueryRowContext(ctx, createPage, arg.Domain, arg.Searchdeep, arg.Maxsearchdeep)
	var i Page
	err := row.Scan(
		&i.ID,
		&i.Domain,
		&i.Searchdeep,
		&i.Maxsearchdeep,
	)
	return i, err
}

const getAllPages = `-- name: GetAllPages :many
SELECT id, domain, searchdeep, maxsearchdeep FROM pages
`

func (q *Queries) GetAllPages(ctx context.Context) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, getAllPages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Searchdeep,
			&i.Maxsearchdeep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLinksByPageID = `-- name: GetLinksByPageID :many
SELECT l.id, l.domain, l.statusCode
FROM links l
INNER JOIN pageslinks pl ON l.id = pl.links_id
WHERE pl.pages_id = $1
`

type GetLinksByPageIDRow struct {
	ID         int32          `json:"id"`
	Domain     sql.NullString `json:"domain"`
	Statuscode sql.NullInt32  `json:"statuscode"`
}

func (q *Queries) GetLinksByPageID(ctx context.Context, pagesID sql.NullInt32) ([]GetLinksByPageIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getLinksByPageID, pagesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLinksByPageIDRow
	for rows.Next() {
		var i GetLinksByPageIDRow
		if err := rows.Scan(&i.ID, &i.Domain, &i.Statuscode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPageByDomain = `-- name: GetPageByDomain :many
SELECT id, domain, searchdeep, maxsearchdeep FROM pages WHERE domain LIKE $1
`

func (q *Queries) GetPageByDomain(ctx context.Context, domain sql.NullString) ([]Page, error) {
	rows, err := q.db.QueryContext(ctx, getPageByDomain, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Page
	for rows.Next() {
		var i Page
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.Searchdeep,
			&i.Maxsearchdeep,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrGetLink = `-- name: InsertOrGetLink :one
/* -- name: CreateLink :many
INSERT INTO links (domain) VALUES ($1) RETURNING id; */

INSERT INTO links (domain,statusCode)
VALUES ($1,$2)
ON CONFLICT (domain) DO UPDATE 
SET domain = EXCLUDED.domain
RETURNING id
`

type InsertOrGetLinkParams struct {
	Domain     sql.NullString `json:"domain"`
	Statuscode sql.NullInt32  `json:"statuscode"`
}

func (q *Queries) InsertOrGetLink(ctx context.Context, arg InsertOrGetLinkParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertOrGetLink, arg.Domain, arg.Statuscode)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertPageLinkAssociation = `-- name: InsertPageLinkAssociation :exec
INSERT INTO pageslinks (pages_id, links_id)
VALUES ($1, $2)
ON CONFLICT (pages_id, links_id) DO NOTHING
`

type InsertPageLinkAssociationParams struct {
	PagesID sql.NullInt32 `json:"pages_id"`
	LinksID sql.NullInt32 `json:"links_id"`
}

func (q *Queries) InsertPageLinkAssociation(ctx context.Context, arg InsertPageLinkAssociationParams) error {
	_, err := q.db.ExecContext(ctx, insertPageLinkAssociation, arg.PagesID, arg.LinksID)
	return err
}

const upsertPage = `-- name: UpsertPage :one
INSERT INTO pages (domain, searchDeep, maxSearchDeep)
VALUES ($1, $2, $3)
ON CONFLICT (domain) DO UPDATE 
SET searchDeep = EXCLUDED.searchDeep, maxSearchDeep = EXCLUDED.maxSearchDeep
RETURNING id
`

type UpsertPageParams struct {
	Domain        sql.NullString `json:"domain"`
	Searchdeep    sql.NullInt32  `json:"searchdeep"`
	Maxsearchdeep sql.NullInt32  `json:"maxsearchdeep"`
}

func (q *Queries) UpsertPage(ctx context.Context, arg UpsertPageParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, upsertPage, arg.Domain, arg.Searchdeep, arg.Maxsearchdeep)
	var id int32
	err := row.Scan(&id)
	return id, err
}
